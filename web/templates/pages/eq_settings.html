{% extends "layout.html" %}
{% import "components/buttons.html" as buttons %}
{% import "components/card_panel.html" as panels %}
{% import "components/forms.html" as forms %}
{% import "components/slider_input.html" as sliders %}

{% block content %}
<div x-data="eqApp()" x-init="init()">
  <header class="page-header">
    <h1 class="page-title">{{ t('eq_page_title') }}</h1>
    <p class="page-subtitle">{{ t('eq_page_subtitle') }}</p>
  </header>

  <div class="grid grid-2">
    {% call panels.card_panel(t('section_system_status')) %}
      <div class="info-row">
        <div>
          <div class="muted">{{ t('label_state') }}</div>
          <div class="mono" x-text="status.state"></div>
        </div>
        <span class="badge" :class="status.daemon_running ? 'badge-on' : 'badge-off'" x-text="status.daemon_running ? t('status_running') : t('status_stopped')"></span>
      </div>
      <div class="info-row">
        <div class="muted">{{ t('label_input_rate') }}</div>
        <div class="mono" x-text="formatRate(status.input_rate)"></div>
      </div>
      <div class="info-row">
        <div class="muted">{{ t('label_output_rate') }}</div>
        <div class="mono" x-text="formatRate(status.output_rate)"></div>
      </div>
      <div class="info-row">
        <div class="muted">{{ t('label_xrun_total') }}</div>
        <div class="mono" x-text="status.xrun_total"></div>
      </div>
      <div class="info-row" x-show="status.uptime_ms !== null">
        <div class="muted">{{ t('label_uptime') }}</div>
        <div class="mono" x-text="formatUptime(status.uptime_ms)"></div>
      </div>
      <div class="info-row" x-show="status.phase_type">
        <div class="muted">{{ t('label_phase') }}</div>
        <div class="mono" x-text="status.phase_type"></div>
      </div>
    {% endcall %}

    {% call panels.card_panel(t('section_dsp_controls')) %}
      <div class="info-row">
        <div>
          <div class="muted">{{ t('label_phase') }}</div>
          <div class="mono" x-text="phaseType"></div>
        </div>
        <div class="profile-actions">
          {{ buttons.btn_primary(t('btn_minimum'), click="setPhase('minimum')", disabled="actionPending || phaseType === 'minimum'", attrs=":class=\"phaseType === 'minimum' ? '' : 'btn-secondary'\"") }}
          {{ buttons.btn_primary(t('btn_linear'), click="setPhase('linear')", disabled="actionPending || phaseType === 'linear'", attrs=":class=\"phaseType === 'linear' ? '' : 'btn-secondary'\"") }}
        </div>
      </div>
      <div class="profile-actions" style="margin-top: 12px;">
        {{ buttons.btn_primary(t('btn_reload'), click='requestReload()', disabled='actionPending') }}
        {{ buttons.btn_primary(t('btn_soft_reset'), click='requestSoftReset()', disabled='actionPending', extra_class='btn-secondary') }}
        {{ buttons.btn_primary(t('btn_refresh_status'), click='fetchStatus()', disabled='actionPending', extra_class='btn-secondary') }}
      </div>
      <div class="notice success" x-show="actionMessage" x-text="actionMessage" style="margin-top: 16px;"></div>
      <div class="notice error" x-show="actionError" x-text="actionError" style="margin-top: 16px;"></div>
    {% endcall %}
  </div>

  <div class="grid grid-2">
    {% call panels.card_panel(t('section_active_profile')) %}
      <div class="info-row">
        <div>
          <div class="mono" x-text="activeEq.name || t('label_none')"></div>
          <div class="muted" x-text="activeEq.active ? t('text_profile_active') : t('text_profile_inactive')"></div>
        </div>
        <span class="badge" :class="activeEq.active ? 'badge-on' : 'badge-off'" x-text="activeEq.active ? t('badge_on') : t('badge_off')"></span>
      </div>
      <div class="info-row" x-show="activeEq.active && activeEq.source_type">
        <div class="muted">{{ t('label_source') }}</div>
        <div class="mono" x-text="activeEq.source_type"></div>
      </div>
      <div class="info-row" x-show="activeEq.active && activeEq.has_modern_target">
        <div class="muted">{{ t('label_modern_target') }}</div>
        <div class="badge badge-warning">{{ t('label_kb5000') }}</div>
      </div>
      <div class="notice warning" x-show="activeEq.error" x-text="activeEq.error"></div>
      <div class="profile-actions" style="margin-top: 16px;">
        {{ buttons.btn_primary(t('btn_deactivate_eq'), click='deactivateEq()', disabled='!activeEq.active', extra_class='btn-secondary') }}
      </div>
    {% endcall %}

    {% call panels.card_panel(t('section_upload_validate')) %}
      <div class="form-group">
        <label for="eqFile">{{ t('label_eq_profile_file') }}</label>
        <input id="eqFile" type="file" accept=".txt" @change="handleFile($event)">
      </div>
      <div class="profile-actions">
        {{ buttons.btn_primary(t('btn_validate'), click='validateUpload()', disabled='!upload.file') }}
        {{ buttons.btn_primary(t('btn_import'), click='importProfile()', disabled='!upload.file') }}
      </div>

      <div class="notice" x-show="validation && validation.valid">
        {{ t('text_validation_passed') }} <span class="mono" x-text="validation.filter_count"></span> {{ t('text_filters_suffix') }}
      </div>
      <div class="notice error" x-show="validation && validation.errors.length">
        <template x-for="err in validation.errors" :key="err">
          <div x-text="err"></div>
        </template>
      </div>
      <div class="notice warning" x-show="validation && validation.warnings.length">
        <template x-for="warn in validation.warnings" :key="warn">
          <div x-text="warn"></div>
        </template>
      </div>

      <div x-show="validation && validation.preamp_db !== null" style="margin-top: 16px;">
        <div class="info-row">
          <div class="muted">{{ t('label_preamp_from_file') }}</div>
          <div class="mono" x-text="validation.preamp_db + ' dB'"></div>
        </div>
        {{ sliders.slider_input(min=-30, max=0, step=0.1, model='recommendedPreamp', disabled='true', label=t('label_recommended_preamp'), id='recommendedPreamp') }}
      </div>
    {% endcall %}
  </div>

  {% call panels.card_panel(t('section_opra_search')) %}
    {% include 'components/opra_search.html' %}
    <div class="profile-actions" style="margin-top: 12px;">
      {{ buttons.btn_primary(t('btn_apply_opra'), icon='âœ“', click='applyOPRA()', disabled='!opra.selected || opraActionPending') }}
    </div>
    <div class="notice success" x-show="opraMessage" x-text="opraMessage" style="margin-top: 12px;"></div>
    <div class="notice error" x-show="opraError" x-text="opraError" style="margin-top: 12px;"></div>
    <div class="opra-license" style="margin-top: 16px;">
      {{ t('text_eq_data_prefix') }} <a href="https://github.com/opra-project/OPRA" target="_blank" rel="noopener noreferrer">{{ t('text_opra_project') }}</a> {{ t('text_opra_license_suffix') }}
    </div>
  {% endcall %}

  {% call panels.card_panel(t('section_saved_profiles')) %}
    <div class="profile-list" x-show="profiles.length">
      <template x-for="profile in profiles" :key="profile.name">
        <div class="profile-item">
          <div>
            <div class="mono" x-text="profile.name"></div>
            <div class="muted" x-text="profile.filter_count + ' ' + t('text_filters_count')"></div>
          </div>
          <div class="profile-actions">
            {{ buttons.btn_primary(t('btn_activate'), click="activateProfile(profile.name)", disabled="activeEq.name === profile.name") }}
          </div>
        </div>
      </template>
    </div>
    <div class="notice" x-show="!profiles.length">{{ t('text_no_saved_profiles') }}</div>
  {% endcall %}

  {% call panels.card_panel(t('section_opra_sync')) %}
    <div class="info-row">
      <div>
        <div class="muted">{{ t('label_status') }}</div>
        <div class="mono" x-text="formatOpraStatus(opraSync.status?.status)"></div>
      </div>
      <span class="badge" :class="opraSyncBadgeClass()" x-text="opraSyncBadgeText()"></span>
    </div>
    <div class="info-row" style="margin-top: 12px;">
      <div class="muted">{{ t('label_current_commit') }}</div>
      <div class="mono" x-text="opraSync.status?.current_commit || t('text_dash')"></div>
    </div>
    <div class="info-row">
      <div class="muted">{{ t('label_previous_commit') }}</div>
      <div class="mono" x-text="opraSync.status?.previous_commit || t('text_dash')"></div>
    </div>
    <div class="info-row">
      <div class="muted">{{ t('label_downloaded_at') }}</div>
      <div class="mono" x-text="formatIso(opraSync.status?.current_metadata?.downloaded_at)"></div>
    </div>
    <div class="info-row" x-show="opraSync.status?.last_error">
      <div class="muted">{{ t('label_last_error') }}</div>
      <div class="mono" x-text="opraSync.status?.last_error"></div>
    </div>

    {{ forms.text_input('opraSyncTarget', t('label_source_target'), 'opraSync.targetRef', placeholder=t('placeholder_latest_or_sha'), disabled='opraSync.loading || opraSync.status?.status === \"running\"') }}

    <div class="profile-actions">
      {{ buttons.btn_primary(t('btn_check_updates'), click='checkOpraAvailable()', disabled='opraSync.loading') }}
      {{ buttons.btn_primary(t('btn_update'), click='startOpraUpdate()', disabled='opraSync.loading || opraSync.status?.status === \"running\"') }}
      {{ buttons.btn_primary(t('btn_rollback'), click='startOpraRollback()', disabled='opraSync.loading || opraSync.status?.status === \"running\" || !opraSync.status?.previous_commit', extra_class='btn-secondary') }}
    </div>

    <div class="notice success" x-show="opraSync.message" x-text="opraSync.message" style="margin-top: 16px;"></div>
    <div class="notice error" x-show="opraSync.error" x-text="opraSync.error" style="margin-top: 16px;"></div>
  {% endcall %}
</div>

<script>
function eqApp() {
  return {
    activeEq: { active: false, name: null, error: null, source_type: null, has_modern_target: false },
    profiles: [],
    validation: null,
    upload: { file: null },
    opraSync: {
      targetRef: 'latest',
      status: null,
      available: null,
      loading: false,
      message: null,
      error: null
    },
    recommendedPreamp: 0,
    opra: {
      searchQuery: '',
      results: [],
      selected: null,
      eqProfiles: [],
      selectedEqId: '',
      useModernTarget: true,
      searching: false
    },
    opraActionPending: false,
    opraMessage: null,
    opraError: null,
    status: {
      daemon_running: false,
      state: 'stopped',
      input_rate: 0,
      output_rate: 0,
      xrun_total: 0,
      phase_type: null,
      uptime_ms: null,
      reloads: null,
      soft_resets: null
    },
    phaseType: 'minimum',
    actionPending: false,
    actionMessage: null,
    actionError: null,
    statusTimer: null,
    opraTimer: null,
    init() {
      this.refreshAll();
      this.statusTimer = setInterval(() => {
        this.fetchStatus();
      }, 2000);
      this.opraTimer = setInterval(() => {
        this.fetchOpraSyncStatus();
      }, 5000);
    },
    async refreshAll() {
      await Promise.all([
        this.fetchActive(),
        this.fetchProfiles(),
        this.fetchStatus(),
        this.fetchPhase(),
        this.fetchOpraSyncStatus()
      ]);
    },
    async fetchActive() {
      const response = await fetch('/api/eq/active');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      this.activeEq = data;
    },
    async fetchProfiles() {
      const response = await fetch('/api/eq/profiles');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      this.profiles = data.profiles || [];
    },
    async fetchStatus() {
      const response = await fetch('/api/status');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      this.status = data;
      if (data.phase_type) {
        this.phaseType = data.phase_type;
      }
    },
    async fetchPhase() {
      const response = await fetch('/api/daemon/phase-type');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      if (data.phase_type) {
        this.phaseType = data.phase_type;
      }
    },
    formatIso(isoString) {
      if (!isoString) {
        return t('text_dash');
      }
      try {
        return new Date(isoString).toLocaleString();
      } catch (err) {
        return String(isoString);
      }
    },
    formatOpraStatus(status) {
      const normalized = String(status || 'idle').toLowerCase();
      if (normalized === 'running') return t('opra_status_running');
      if (normalized === 'ready') return t('opra_status_ready');
      if (normalized === 'failed') return t('opra_status_failed');
      return t('opra_status_idle');
    },
    opraSyncBadgeClass() {
      const normalized = String(this.opraSync.status?.status || 'idle').toLowerCase();
      if (normalized === 'running') return 'badge-warning';
      if (normalized === 'ready') return 'badge-on';
      return 'badge-off';
    },
    opraSyncBadgeText() {
      const normalized = String(this.opraSync.status?.status || 'idle').toLowerCase();
      if (normalized === 'running') return t('opra_badge_running');
      if (normalized === 'ready') return t('opra_badge_ready');
      if (normalized === 'failed') return t('opra_badge_failed');
      return t('opra_badge_idle');
    },
    resolveOpraSyncParams() {
      const ref = String(this.opraSync.targetRef || '').trim();
      const normalized = ref.toLowerCase();
      const source = normalized === 'cloudflare' ? 'cloudflare' : 'github_raw';
      const target =
        normalized === '' ||
        normalized === 'latest' ||
        normalized === 'cloudflare' ||
        normalized === 'github_raw'
          ? 'latest'
          : ref;
      return { source, target };
    },
    async fetchOpraSyncStatus() {
      try {
        const response = await fetch('/api/opra/sync/status');
        if (!response.ok) {
          return;
        }
        const data = await response.json();
        this.opraSync.status = data;
      } catch (err) {
        console.error('Failed to fetch OPRA sync status:', err);
      }
    },
    async checkOpraAvailable() {
      if (this.opraSync.loading) {
        return;
      }
      const { source } = this.resolveOpraSyncParams();
      this.opraSync.loading = true;
      this.opraSync.message = null;
      this.opraSync.error = null;
      try {
        const response = await fetch(`/api/opra/sync/available?source=${encodeURIComponent(source)}`);
        const data = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(data.detail || data.message || t('error_failed_check_updates'));
        }
        this.opraSync.available = data;
        this.opraSync.message = t('text_latest_available', { value: data.latest || t('label_unknown') });
      } catch (err) {
        this.opraSync.error = err.message || t('error_failed_check_updates');
      } finally {
        this.opraSync.loading = false;
      }
    },
    async startOpraUpdate() {
      if (this.opraSync.loading) {
        return;
      }
      const { source, target } = this.resolveOpraSyncParams();
      if (!confirm(t('confirm_start_opra_update', { target: target }))) {
        return;
      }
      this.opraSync.loading = true;
      this.opraSync.message = null;
      this.opraSync.error = null;
      try {
        const response = await fetch('/api/opra/sync/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ target, source })
        });
        const data = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(data.detail || data.message || t('error_failed_start_update'));
        }
        this.opraSync.message = t('message_opra_update_started');
        await this.fetchOpraSyncStatus();
      } catch (err) {
        this.opraSync.error = err.message || t('error_failed_start_update');
      } finally {
        this.opraSync.loading = false;
      }
    },
    async startOpraRollback() {
      if (this.opraSync.loading) {
        return;
      }
      if (!confirm(t('confirm_opra_rollback'))) {
        return;
      }
      this.opraSync.loading = true;
      this.opraSync.message = null;
      this.opraSync.error = null;
      try {
        const response = await fetch('/api/opra/sync/rollback', { method: 'POST' });
        const data = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(data.detail || data.message || t('error_failed_start_rollback'));
        }
        this.opraSync.message = t('message_opra_rollback_started');
        await this.fetchOpraSyncStatus();
      } catch (err) {
        this.opraSync.error = err.message || t('error_failed_start_rollback');
      } finally {
        this.opraSync.loading = false;
      }
    },
    async searchOPRA() {
      if (!this.opra.searchQuery || this.opra.searchQuery.length < 2) {
        this.opra.results = [];
        return;
      }

      this.opra.searching = true;
      try {
        const response = await fetch(`/opra/search?q=${encodeURIComponent(this.opra.searchQuery)}`);
        if (!response.ok) {
          throw new Error(t('error_search_failed'));
        }
        const data = await response.json();
        this.opra.results = data.results || [];
      } catch (error) {
        console.error('Failed to search OPRA:', error);
        this.opra.results = [];
      } finally {
        this.opra.searching = false;
      }
    },
    selectHeadphone(result) {
      this.opra.selected = result;
      this.opra.results = [];
      this.opra.searchQuery = result.name;
      this.opra.eqProfiles = result.eq_profiles || [];
      this.opra.selectedEqId = this.opra.eqProfiles[0]?.id || '';
    },
    async applyOPRA() {
      if (!this.opra.selected || this.opraActionPending) {
        return;
      }

      this.opraActionPending = true;
      this.opraMessage = null;
      this.opraError = null;
      try {
        const eqId = this.opra.selectedEqId || this.opra.eqProfiles[0]?.id;
        if (!eqId) {
          throw new Error(t('error_no_eq_profile_selected'));
        }

        const endpoint = `/opra/apply/${encodeURIComponent(eqId)}?apply_correction=${this.opra.useModernTarget}`;
        const response = await fetch(endpoint, { method: 'POST' });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || t('error_failed_apply_opra'));
        }

        const data = await response.json();
        this.opraMessage = data.message || t('message_opra_eq_applied');
        await this.fetchActive();
        await this.fetchProfiles();
      } catch (error) {
        console.error('Failed to apply OPRA EQ:', error);
        this.opraError = error.message || t('error_failed_apply_opra');
      } finally {
        this.opraActionPending = false;
      }
    },
    handleFile(event) {
      const files = event.target.files;
      this.upload.file = files && files.length ? files[0] : null;
      this.validation = null;
      this.recommendedPreamp = 0;
    },
    async validateUpload() {
      if (!this.upload.file) {
        return;
      }
      const formData = new FormData();
      formData.append('file', this.upload.file);
      const response = await fetch('/api/eq/validate', { method: 'POST', body: formData });
      const data = await response.json();
      this.validation = data;
      this.recommendedPreamp = data.recommended_preamp_db || 0;
    },
    async importProfile() {
      if (!this.upload.file) {
        return;
      }
      const formData = new FormData();
      formData.append('file', this.upload.file);
      const response = await fetch('/api/eq/import', { method: 'POST', body: formData });
      if (!response.ok) {
        const err = await response.json();
        this.validation = { valid: false, errors: [err.detail || t('error_upload_failed')], warnings: [] };
        return;
      }
      const data = await response.json();
      this.validation = { valid: true, errors: [], warnings: data.data?.warnings || [] };
      this.recommendedPreamp = data.data?.recommended_preamp_db || 0;
      await this.fetchProfiles();
    },
    async activateProfile(name) {
      const response = await fetch(`/api/eq/activate/${encodeURIComponent(name)}`, { method: 'POST' });
      if (!response.ok) {
        return;
      }
      await this.fetchActive();
    },
    async deactivateEq() {
      const response = await fetch('/api/eq/deactivate', { method: 'POST' });
      if (!response.ok) {
        return;
      }
      await this.fetchActive();
    },
    formatRate(rate) {
      if (!rate || rate <= 0) {
        return t('text_dash');
      }
      return `${rate} ${t('unit_hz')}`;
    },
    formatUptime(ms) {
      if (ms === null || ms === undefined) {
        return t('text_dash');
      }
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const remMinutes = minutes % 60;
      const remSeconds = seconds % 60;
      if (hours > 0) {
        return `${hours}${t('unit_hour_short')} ${remMinutes}${t('unit_minute_short')}`;
      }
      if (minutes > 0) {
        return `${minutes}${t('unit_minute_short')} ${remSeconds}${t('unit_second_short')}`;
      }
      return `${remSeconds}${t('unit_second_short')}`;
    },
    async setPhase(phase) {
      this.actionPending = true;
      this.actionMessage = null;
      this.actionError = null;
      try {
        const response = await fetch('/api/daemon/phase-type', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ phase_type: phase })
        });
        if (!response.ok) {
          const err = await response.json();
          this.actionError = err.detail || t('error_phase_update_failed');
          return;
        }
        const data = await response.json();
        this.actionMessage = data.message || t('message_phase_updated');
        this.phaseType = phase;
        await this.fetchStatus();
      } finally {
        this.actionPending = false;
      }
    },
    async requestReload() {
      await this.runDaemonAction('/api/daemon/reload', t('message_reload_requested'));
    },
    async requestSoftReset() {
      await this.runDaemonAction('/api/daemon/soft-reset', t('message_soft_reset_requested'));
    },
    async runDaemonAction(url, successMessage) {
      this.actionPending = true;
      this.actionMessage = null;
      this.actionError = null;
      try {
        const response = await fetch(url, { method: 'POST' });
        if (!response.ok) {
          const err = await response.json();
          this.actionError = err.detail || t('error_command_failed');
          return;
        }
        this.actionMessage = successMessage;
        await this.fetchStatus();
      } finally {
        this.actionPending = false;
      }
    }
  };
}
</script>
{% endblock %}

{% extends "layout.html" %}
{% import "components/buttons.html" as buttons %}
{% import "components/card_panel.html" as panels %}
{% import "components/slider_input.html" as sliders %}

{% block content %}
<div x-data="eqApp()" x-init="init()">
  <header class="page-header">
    <h1 class="page-title">Totton Audio Control</h1>
    <p class="page-subtitle">EQ control, phase switching, and live DSP status.</p>
  </header>

  <div class="grid grid-2">
    {% call panels.card_panel("System Status") %}
      <div class="info-row">
        <div>
          <div class="muted">State</div>
          <div class="mono" x-text="status.state"></div>
        </div>
        <span class="badge" :class="status.daemon_running ? 'badge-on' : 'badge-off'" x-text="status.daemon_running ? 'RUNNING' : 'STOPPED'"></span>
      </div>
      <div class="info-row">
        <div class="muted">Input Rate</div>
        <div class="mono" x-text="formatRate(status.input_rate)"></div>
      </div>
      <div class="info-row">
        <div class="muted">Output Rate</div>
        <div class="mono" x-text="formatRate(status.output_rate)"></div>
      </div>
      <div class="info-row">
        <div class="muted">XRUN Total</div>
        <div class="mono" x-text="status.xrun_total"></div>
      </div>
      <div class="info-row" x-show="status.uptime_ms !== null">
        <div class="muted">Uptime</div>
        <div class="mono" x-text="formatUptime(status.uptime_ms)"></div>
      </div>
      <div class="info-row" x-show="status.phase_type">
        <div class="muted">Phase</div>
        <div class="mono" x-text="status.phase_type"></div>
      </div>
    {% endcall %}

    {% call panels.card_panel("DSP Controls") %}
      <div class="info-row">
        <div>
          <div class="muted">Phase</div>
          <div class="mono" x-text="phaseType"></div>
        </div>
        <div class="profile-actions">
          {{ buttons.btn_primary('Minimum', click="setPhase('minimum')", disabled="actionPending || phaseType === 'minimum'", attrs=":class=\"phaseType === 'minimum' ? '' : 'btn-secondary'\"") }}
          {{ buttons.btn_primary('Linear', click="setPhase('linear')", disabled="actionPending || phaseType === 'linear'", attrs=":class=\"phaseType === 'linear' ? '' : 'btn-secondary'\"") }}
        </div>
      </div>
      <div class="profile-actions" style="margin-top: 12px;">
        {{ buttons.btn_primary('Reload', click='requestReload()', disabled='actionPending') }}
        {{ buttons.btn_primary('Soft Reset', click='requestSoftReset()', disabled='actionPending', extra_class='btn-secondary') }}
        {{ buttons.btn_primary('Refresh Status', click='fetchStatus()', disabled='actionPending', extra_class='btn-secondary') }}
      </div>
      <div class="notice success" x-show="actionMessage" x-text="actionMessage" style="margin-top: 16px;"></div>
      <div class="notice error" x-show="actionError" x-text="actionError" style="margin-top: 16px;"></div>
    {% endcall %}
  </div>

  <div class="grid grid-2">
    {% call panels.card_panel("Active Profile") %}
      <div class="info-row">
        <div>
          <div class="mono" x-text="activeEq.name || 'None'"></div>
          <div class="muted" x-text="activeEq.active ? 'Profile is active' : 'No EQ profile active'"></div>
        </div>
        <span class="badge" :class="activeEq.active ? 'badge-on' : 'badge-off'" x-text="activeEq.active ? 'ON' : 'OFF'"></span>
      </div>
      <div class="info-row" x-show="activeEq.active && activeEq.source_type">
        <div class="muted">Source</div>
        <div class="mono" x-text="activeEq.source_type"></div>
      </div>
      <div class="info-row" x-show="activeEq.active && activeEq.has_modern_target">
        <div class="muted">Modern Target</div>
        <div class="badge badge-warning">KB5000_7</div>
      </div>
      <div class="notice warning" x-show="activeEq.error" x-text="activeEq.error"></div>
      <div class="profile-actions" style="margin-top: 16px;">
        {{ buttons.btn_primary('Deactivate EQ', click='deactivateEq()', disabled='!activeEq.active', extra_class='btn-secondary') }}
      </div>
    {% endcall %}

    {% call panels.card_panel("Upload & Validate") %}
      <div class="form-group">
        <label for="eqFile">EQ Profile (.txt)</label>
        <input id="eqFile" type="file" accept=".txt" @change="handleFile($event)">
      </div>
      <div class="profile-actions">
        {{ buttons.btn_primary('Validate', click='validateUpload()', disabled='!upload.file') }}
        {{ buttons.btn_primary('Import', click='importProfile()', disabled='!upload.file') }}
      </div>

      <div class="notice" x-show="validation && validation.valid">
        Validation passed: <span class="mono" x-text="validation.filter_count"></span> filters.
      </div>
      <div class="notice error" x-show="validation && validation.errors.length">
        <template x-for="err in validation.errors" :key="err">
          <div x-text="err"></div>
        </template>
      </div>
      <div class="notice warning" x-show="validation && validation.warnings.length">
        <template x-for="warn in validation.warnings" :key="warn">
          <div x-text="warn"></div>
        </template>
      </div>

      <div x-show="validation && validation.preamp_db !== null" style="margin-top: 16px;">
        <div class="info-row">
          <div class="muted">Preamp (from file)</div>
          <div class="mono" x-text="validation.preamp_db + ' dB'"></div>
        </div>
        {{ sliders.slider_input(min=-30, max=0, step=0.1, model='recommendedPreamp', disabled='true', label='Recommended Preamp (Headroom)', id='recommendedPreamp') }}
      </div>
    {% endcall %}
  </div>

  {% call panels.card_panel("OPRA Headphone Search") %}
    {% include 'components/opra_search.html' %}
    <div class="profile-actions" style="margin-top: 12px;">
      {{ buttons.btn_primary('Apply OPRA EQ', icon='✓', click='applyOPRA()', disabled='!opra.selected || opraActionPending') }}
    </div>
    <div class="notice success" x-show="opraMessage" x-text="opraMessage" style="margin-top: 12px;"></div>
    <div class="notice error" x-show="opraError" x-text="opraError" style="margin-top: 12px;"></div>
    <div class="opra-license" style="margin-top: 16px;">
      EQ data: <a href="https://github.com/opra-project/OPRA" target="_blank" rel="noopener noreferrer">OPRA Project</a> (CC BY-SA 4.0)
    </div>
  {% endcall %}

  {% call panels.card_panel("Saved Profiles") %}
    <div class="profile-list" x-show="profiles.length">
      <template x-for="profile in profiles" :key="profile.name">
        <div class="profile-item">
          <div>
            <div class="mono" x-text="profile.name"></div>
            <div class="muted" x-text="profile.filter_count + ' filters'"></div>
          </div>
          <div class="profile-actions">
            {{ buttons.btn_primary('Activate', click="activateProfile(profile.name)", disabled="activeEq.name === profile.name") }}
          </div>
        </div>
      </template>
    </div>
    <div class="notice" x-show="!profiles.length">No saved profiles yet.</div>
  {% endcall %}
</div>

<script>
function eqApp() {
  return {
    activeEq: { active: false, name: null, error: null, source_type: null, has_modern_target: false },
    profiles: [],
    validation: null,
    upload: { file: null },
    recommendedPreamp: 0,
    opra: {
      searchQuery: '',
      results: [],
      selected: null,
      eqProfiles: [],
      selectedEqId: '',
      useModernTarget: true,
      searching: false
    },
    opraActionPending: false,
    opraMessage: null,
    opraError: null,
    status: {
      daemon_running: false,
      state: 'stopped',
      input_rate: 0,
      output_rate: 0,
      xrun_total: 0,
      phase_type: null,
      uptime_ms: null,
      reloads: null,
      soft_resets: null
    },
    phaseType: 'minimum',
    actionPending: false,
    actionMessage: null,
    actionError: null,
    statusTimer: null,
    init() {
      this.refreshAll();
      this.statusTimer = setInterval(() => {
        this.fetchStatus();
      }, 2000);
    },
    async refreshAll() {
      await Promise.all([
        this.fetchActive(),
        this.fetchProfiles(),
        this.fetchStatus(),
        this.fetchPhase()
      ]);
    },
    async fetchActive() {
      const response = await fetch('/api/eq/active');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      this.activeEq = data;
    },
    async fetchProfiles() {
      const response = await fetch('/api/eq/profiles');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      this.profiles = data.profiles || [];
    },
    async fetchStatus() {
      const response = await fetch('/api/status');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      this.status = data;
      if (data.phase_type) {
        this.phaseType = data.phase_type;
      }
    },
    async fetchPhase() {
      const response = await fetch('/api/daemon/phase-type');
      if (!response.ok) {
        return;
      }
      const data = await response.json();
      if (data.phase_type) {
        this.phaseType = data.phase_type;
      }
    },
    async searchOPRA() {
      if (!this.opra.searchQuery || this.opra.searchQuery.length < 2) {
        this.opra.results = [];
        return;
      }

      this.opra.searching = true;
      try {
        const response = await fetch(`/opra/search?q=${encodeURIComponent(this.opra.searchQuery)}`);
        if (!response.ok) {
          throw new Error('Search failed');
        }
        const data = await response.json();
        this.opra.results = data.results || [];
      } catch (error) {
        console.error('Failed to search OPRA:', error);
        this.opra.results = [];
      } finally {
        this.opra.searching = false;
      }
    },
    selectHeadphone(result) {
      this.opra.selected = result;
      this.opra.results = [];
      this.opra.searchQuery = result.name;
      this.opra.eqProfiles = result.eq_profiles || [];
      this.opra.selectedEqId = this.opra.eqProfiles[0]?.id || '';
    },
    async applyOPRA() {
      if (!this.opra.selected || this.opraActionPending) {
        return;
      }

      this.opraActionPending = true;
      this.opraMessage = null;
      this.opraError = null;
      try {
        const eqId = this.opra.selectedEqId || this.opra.eqProfiles[0]?.id;
        if (!eqId) {
          throw new Error('No EQ profile selected');
        }

        const endpoint = `/opra/apply/${encodeURIComponent(eqId)}?apply_correction=${this.opra.useModernTarget}`;
        const response = await fetch(endpoint, { method: 'POST' });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.detail || 'Failed to apply OPRA EQ');
        }

        const data = await response.json();
        this.opraMessage = data.message || 'OPRA EQ applied';
        await this.fetchActive();
        await this.fetchProfiles();
      } catch (error) {
        console.error('Failed to apply OPRA EQ:', error);
        this.opraError = error.message || 'Failed to apply OPRA EQ';
      } finally {
        this.opraActionPending = false;
      }
    },
    handleFile(event) {
      const files = event.target.files;
      this.upload.file = files && files.length ? files[0] : null;
      this.validation = null;
      this.recommendedPreamp = 0;
    },
    async validateUpload() {
      if (!this.upload.file) {
        return;
      }
      const formData = new FormData();
      formData.append('file', this.upload.file);
      const response = await fetch('/api/eq/validate', { method: 'POST', body: formData });
      const data = await response.json();
      this.validation = data;
      this.recommendedPreamp = data.recommended_preamp_db || 0;
    },
    async importProfile() {
      if (!this.upload.file) {
        return;
      }
      const formData = new FormData();
      formData.append('file', this.upload.file);
      const response = await fetch('/api/eq/import', { method: 'POST', body: formData });
      if (!response.ok) {
        const err = await response.json();
        this.validation = { valid: false, errors: [err.detail || 'Upload failed'], warnings: [] };
        return;
      }
      const data = await response.json();
      this.validation = { valid: true, errors: [], warnings: data.data?.warnings || [] };
      this.recommendedPreamp = data.data?.recommended_preamp_db || 0;
      await this.fetchProfiles();
    },
    async activateProfile(name) {
      const response = await fetch(`/api/eq/activate/${encodeURIComponent(name)}`, { method: 'POST' });
      if (!response.ok) {
        return;
      }
      await this.fetchActive();
    },
    async deactivateEq() {
      const response = await fetch('/api/eq/deactivate', { method: 'POST' });
      if (!response.ok) {
        return;
      }
      await this.fetchActive();
    },
    formatRate(rate) {
      if (!rate || rate <= 0) {
        return '—';
      }
      return `${rate} Hz`;
    },
    formatUptime(ms) {
      if (ms === null || ms === undefined) {
        return '—';
      }
      const seconds = Math.floor(ms / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const remMinutes = minutes % 60;
      const remSeconds = seconds % 60;
      if (hours > 0) {
        return `${hours}h ${remMinutes}m`;
      }
      if (minutes > 0) {
        return `${minutes}m ${remSeconds}s`;
      }
      return `${remSeconds}s`;
    },
    async setPhase(phase) {
      this.actionPending = true;
      this.actionMessage = null;
      this.actionError = null;
      try {
        const response = await fetch('/api/daemon/phase-type', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ phase_type: phase })
        });
        if (!response.ok) {
          const err = await response.json();
          this.actionError = err.detail || 'Phase update failed';
          return;
        }
        const data = await response.json();
        this.actionMessage = data.message || 'Phase updated';
        this.phaseType = phase;
        await this.fetchStatus();
      } finally {
        this.actionPending = false;
      }
    },
    async requestReload() {
      await this.runDaemonAction('/api/daemon/reload', 'Reload requested');
    },
    async requestSoftReset() {
      await this.runDaemonAction('/api/daemon/soft-reset', 'Soft reset requested');
    },
    async runDaemonAction(url, successMessage) {
      this.actionPending = true;
      this.actionMessage = null;
      this.actionError = null;
      try {
        const response = await fetch(url, { method: 'POST' });
        if (!response.ok) {
          const err = await response.json();
          this.actionError = err.detail || 'Command failed';
          return;
        }
        this.actionMessage = successMessage;
        await this.fetchStatus();
      } finally {
        this.actionPending = false;
      }
    }
  };
}
</script>
{% endblock %}
